<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>Android之SlidingPaneLayout侧滑效果扩展（SuperSlidingPaneLayout）</title>
      <link href="/posts/1790930363.html"/>
      <url>/posts/1790930363.html</url>
      
        <content type="html"><![CDATA[<h3 id="前言："><a href="#前言：" class="headerlink" title="前言："></a>前言：</h3><p>说到侧滑菜单，记得在很久很久以前，一说到侧滑菜单就会立刻想到SlidingMenu，在当时的印象里比较火的侧滑菜单就是SlidingMenu，最开始觉得那种效果还蛮新颖的，后来Google官方出了SlidingPaneLayout和DrawerLayout后，大部分的侧滑菜单效果也就基本被满足了。本博文主要讲到基于官方v4扩展包中的SlidingPaneLayout来扩展侧滑效果，我给SldingPaneLayout的扩展控件取了个好听的名字叫：<code>SuperSlidingPaneLayout</code></p><blockquote><p>说到侧滑效果扩展，这里主要用到了平移、缩放、等效果组合来达到想要的效果。</p></blockquote><h3 id="首先"><a href="#首先" class="headerlink" title="首先:"></a>首先:</h3><p>我们在<code>SuperSlidingPaneLayout</code>中定义一个枚举来表示不同的侧滑效果模式：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">enum</span> <span class="title class_">Mode</span> &#123;</span><br><span class="line"></span><br><span class="line">        DEFAULT(<span class="number">0</span>),</span><br><span class="line">        TRANSLATION(<span class="number">1</span>),</span><br><span class="line">        SCALE_MENU(<span class="number">2</span>),</span><br><span class="line">        SCALE_PANEL(<span class="number">3</span>),</span><br><span class="line">        SCALE_BOTH(<span class="number">4</span>),</span><br><span class="line">        TRANSLATION_SCALE(<span class="number">5</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">private</span> <span class="type">int</span> mValue;</span><br><span class="line"></span><br><span class="line">        Mode(<span class="type">int</span> value)&#123;</span><br><span class="line">            <span class="built_in">this</span>.mValue = value;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">static</span> Mode <span class="title function_">getFromInt</span><span class="params">(<span class="type">int</span> value)</span>&#123;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">for</span>(Mode mode : Mode.values())&#123;</span><br><span class="line">                <span class="keyword">if</span>(mode.mValue == value)</span><br><span class="line">                    <span class="keyword">return</span> mode;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">return</span> DEFAULT;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="接着"><a href="#接着" class="headerlink" title="接着:"></a>接着:</h3><p>我们可以在SlidingPaneLayout源码中找到一个dispatchOnPanelSlide方法，其代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> <span class="title function_">dispatchOnPanelSlide</span><span class="params">(View panel)</span> &#123;</span><br><span class="line">      <span class="keyword">if</span> (mPanelSlideListener != <span class="literal">null</span>) &#123;</span><br><span class="line">          mPanelSlideListener.onPanelSlide(panel, mSlideOffset);</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="思考："><a href="#思考：" class="headerlink" title="思考："></a>思考：</h3><p>从方法字面意思我们不难看出这是一个调度面板滑动的方法，说白了就是里面就是一个面板滑动的监听事件，我们可以通过(slidingPaneLayout.setPanelSlideListener)设置监听来监听面板的滑动情况，既然是扩展，就不想影响监听事件，这里我们在SuperSlidingPaneLayout中新增一个方法，代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">dispatchOnPanelMode</span><span class="params">(View panel, <span class="type">float</span> slideOffset)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (mMenuPanel == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">final</span> <span class="type">int</span> <span class="variable">childCount</span> <span class="operator">=</span> getChildCount();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; childCount; i++) &#123;</span><br><span class="line">            <span class="keyword">final</span> <span class="type">View</span> <span class="variable">child</span> <span class="operator">=</span> getChildAt(i);</span><br><span class="line">            <span class="keyword">if</span> (child != panel) &#123;</span><br><span class="line">                mMenuPanel = child;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">final</span> <span class="type">float</span> <span class="variable">scale</span> <span class="operator">=</span> <span class="number">1</span> - <span class="number">0.2f</span> * slideOffset;</span><br><span class="line">    <span class="keyword">final</span> <span class="type">float</span> <span class="variable">scaleLeft</span> <span class="operator">=</span> <span class="number">1</span> - <span class="number">0.2f</span> * (<span class="number">1</span> - slideOffset);</span><br><span class="line">    <span class="keyword">switch</span> (mMode)&#123;</span><br><span class="line">        <span class="keyword">case</span> TRANSLATION:<span class="comment">//平移效果</span></span><br><span class="line">            mMenuPanel.setTranslationX((slideOffset-<span class="number">1</span>) * mMenuPanel.getWidth());</span><br><span class="line">            panel.setScaleX(<span class="number">1</span>);</span><br><span class="line">            panel.setScaleY(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> SCALE_MENU:<span class="comment">//缩放菜单效果</span></span><br><span class="line">            mMenuPanel.setPivotX(-<span class="number">0.2f</span> * mMenuPanel.getWidth());</span><br><span class="line">            mMenuPanel.setPivotY(mMenuPanel.getHeight() / <span class="number">2.0f</span>);</span><br><span class="line">            mMenuPanel.setScaleX(scaleLeft);</span><br><span class="line">            mMenuPanel.setScaleY(scaleLeft);</span><br><span class="line">            panel.setScaleX(<span class="number">1</span>);</span><br><span class="line">            panel.setScaleY(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> SCALE_PANEL:<span class="comment">//缩放面板效果</span></span><br><span class="line">            panel.setPivotX(<span class="number">0</span>);</span><br><span class="line">            panel.setPivotY(panel.getHeight()/<span class="number">2.0f</span>);</span><br><span class="line">            panel.setScaleX(scale);</span><br><span class="line">            panel.setScaleY(scale);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> SCALE_BOTH:<span class="comment">//菜单面板都缩放效果</span></span><br><span class="line">            mMenuPanel.setPivotX(-<span class="number">0.2f</span> * mMenuPanel.getWidth());</span><br><span class="line">            mMenuPanel.setPivotY(mMenuPanel.getHeight() / <span class="number">2.0f</span>);</span><br><span class="line">            mMenuPanel.setScaleX(scaleLeft);</span><br><span class="line">            mMenuPanel.setScaleY(scaleLeft);</span><br><span class="line"></span><br><span class="line">            panel.setPivotX(<span class="number">0</span>);</span><br><span class="line">            panel.setPivotY(panel.getHeight()/<span class="number">2.0f</span>);</span><br><span class="line">            panel.setScaleX(scale);</span><br><span class="line">            panel.setScaleY(scale);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> TRANSLATION_SCALE:<span class="comment">//平移缩放效果</span></span><br><span class="line">            mMenuPanel.setTranslationX((slideOffset-<span class="number">1</span>) * mMenuPanel.getWidth() / <span class="number">2.0f</span>);</span><br><span class="line">            mMenuPanel.setPivotX(-<span class="number">0.2f</span> * mMenuPanel.getWidth());</span><br><span class="line">            mMenuPanel.setPivotY(mMenuPanel.getHeight() / <span class="number">2.0f</span>);</span><br><span class="line">            mMenuPanel.setScaleX(scaleLeft);</span><br><span class="line">            mMenuPanel.setScaleY(scaleLeft);</span><br><span class="line"></span><br><span class="line">            panel.setPivotX(<span class="number">0</span>);</span><br><span class="line">            panel.setPivotY(panel.getHeight()/<span class="number">2.0f</span>);</span><br><span class="line">            panel.setScaleX(scale);</span><br><span class="line">            panel.setScaleY(scale);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> DEFAULT:<span class="comment">//默认 即菜单固定</span></span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">            panel.setPivotX(<span class="number">0</span>);</span><br><span class="line">            panel.setPivotY(<span class="number">0</span>);</span><br><span class="line">            panel.setScaleX(<span class="number">1</span>);</span><br><span class="line">            panel.setScaleY(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="解读："><a href="#解读：" class="headerlink" title="解读："></a>解读：</h3><p>在这里简单说明下上面代码的意思，上面代码逻辑主要根据面板的偏移量来进行缩放、平移面板或菜单，达到不同的侧滑效果。</p><h3 id="然后："><a href="#然后：" class="headerlink" title="然后："></a>然后：</h3><p>在<code>dispatchOnPanelSlide</code>中调用一下就可以了，代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> <span class="title function_">dispatchOnPanelSlide</span><span class="params">(View panel)</span> &#123;</span><br><span class="line">    dispatchOnPanelMode(panel,mSlideOffset);</span><br><span class="line">    <span class="keyword">if</span> (mPanelSlideListener != <span class="literal">null</span>) &#123;</span><br><span class="line">        mPanelSlideListener.onPanelSlide(panel, mSlideOffset);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="收工："><a href="#收工：" class="headerlink" title="收工："></a>收工：</h3><p>这样几种不同的侧滑效果就算完成了，有木有很简单？下面我们来看下最终的效果图：<br><img src="/../images/article/20161008172543455.gif"></p><p><a href="https://github.com/jenly1314/SuperSlidingPaneLayout">SuperSlidingPaneLayout</a>最新源码已上传至<code>github</code>欢迎<code>Star</code>和<code>Fork</code>。</p>]]></content>
      
      
      <categories>
          
          <category> Android </category>
          
      </categories>
      
      
        <tags>
            
            <tag> SlidingPaneLayout </tag>
            
            <tag> 仿QQ侧滑效果 </tag>
            
            <tag> Android </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>代码统计工具实测点评</title>
      <link href="/posts/2582324225.html"/>
      <url>/posts/2582324225.html</url>
      
        <content type="html"><![CDATA[<h2 id="1-CodeMetric"><a href="#1-CodeMetric" class="headerlink" title="1. CodeMetric:"></a>1. CodeMetric:</h2><p>CodeMetric启动后（如下图）<br><img src="/../images/article/20160926164144778.png"> </p><h3 id="1-1-代码统计项："><a href="#1-1-代码统计项：" class="headerlink" title="1.1. 代码统计项："></a>1.1. 代码统计项：</h3><p>代码统计主要包括：注释行、空白行、代码行、总行数（不包括空白行）、总行数（包括空白行）、注释率、空白率、字符数。（也就是下图里面的度量项）</p><h3 id="1-2-基本操作："><a href="#1-2-基本操作：" class="headerlink" title="1.2. 基本操作："></a>1.2. 基本操作：</h3><ol><li>通过点击按钮添加目录&#x2F;文件添加需要统计的目录&#x2F;文件。</li><li>选择好代码语言类型，代码文件后缀输入框里面的内容，会自动变成选择的代码语言类型默认文件的后缀，也可以自定义添加代码文件后缀。</li><li>勾选想要统计的度量项。</li><li>点击度量按钮便可以进行统计。</li></ol><h3 id="1-3-统计输出格式："><a href="#1-3-统计输出格式：" class="headerlink" title="1.3. 统计输出格式："></a>1.3. 统计输出格式：</h3><p>统计输出格式主要分为两种：简单输出格式和XML输出格式。</p><ol><li><p>简单输出格式：<br><img src="/../images/article/20160926164214685.png"></p></li><li><p>XML输出格式：<br><img src="/../images/article/20160926164232935.png"></p></li></ol><h3 id="1-4-实测点评："><a href="#1-4-实测点评：" class="headerlink" title="1.4. 实测点评："></a>1.4. 实测点评：</h3><p>对比两种统计输出格式：</p><ol><li>简单文本格式：可读性还是比较清晰的。</li><li>XML格式：可读性一般，看起来比较繁杂一点。</li></ol><h4 id="两个细节问题："><a href="#两个细节问题：" class="headerlink" title="两个细节问题："></a>两个细节问题：</h4><ol><li><p>注释里面的空白行会计算进去，统计注释行数与实际注释行数有所偏高。</p></li><li><p>显示细节错误：注释率（SLOC&#x2F;TTL） ——〉注释率（CMTL&#x2F;TTL）</p><p> 除去上面两个细节问题，整体上来看还算不错，功能比较简单。（如下图）</p></li></ol><p><img src="/../images/article/20160926164254060.png"></p><h2 id="2-ICodeStat"><a href="#2-ICodeStat" class="headerlink" title="2. ICodeStat:"></a>2. ICodeStat:</h2><p>启动ICodeStat后，可以看到ICodeStat主要有四个功能，分别是：批处理、版本比较、脚本拆分、代码统计。(如下图)<br><img src="/../images/article/20160926164312012.png"></p><h3 id="2-1-代码统计项："><a href="#2-1-代码统计项：" class="headerlink" title="2.1. 代码统计项："></a>2.1. 代码统计项：</h3><p>代码统计主要包括：注释行、空白行、代码行、总行数（不包括空白行）、总文件数、注释率、空白率。</p><h3 id="2-2-基本操作："><a href="#2-2-基本操作：" class="headerlink" title="2.2. 基本操作："></a>2.2. 基本操作：</h3><ol><li>通过选择代码统计功能，下面的组合输入框变为文件类型和文件夹，文件类型可以通过输入框选择预先设置好的类型，也可以手工修改和输入，文件夹可以手工输入也可以通过目录选择对话框选择。</li><li>选择好文件类型和文件夹后，点击处理就可以开始代码统计工作，通过选择文件类型，可以实现对不同类型的代码进行分别统计的目的。</li><li>统计完成后，在下面的统计结果栏中会显示总体的统计结果，在列表框中会保存每个文件的统计结果。</li></ol><h3 id="2-3-统计输出格式："><a href="#2-3-统计输出格式：" class="headerlink" title="2.3. 统计输出格式："></a>2.3. 统计输出格式：</h3><p>统计输出类似表格的形式，（如下图）<br><img src="/../images/article/20160926164429702.png"> </p><h3 id="2-4-实测点评："><a href="#2-4-实测点评：" class="headerlink" title="2.4. 实测点评："></a>2.4. 实测点评：</h3><p>统计输出格式以类似表格的输出方式展现，看起来一目了然。<br>统计准确，无误差，推荐使用。</p><h2 id="3-StatSVN："><a href="#3-StatSVN：" class="headerlink" title="3. StatSVN："></a>3. StatSVN：</h2><h3 id="3-1-相关说明："><a href="#3-1-相关说明：" class="headerlink" title="3.1. 相关说明："></a>3.1. 相关说明：</h3><p>StatSVN是一个Java写的开源代码统计程序，从statCVS移植而来，能够从Subversion版本库中取得信息，然后生成描述项目开发的各种表格和图表。比如：代码行数的时间线；针对每个开发者的代码行数；开发者的活跃程度；开发者最近所提交的；文件数量；平均文件大小；最大文件；哪个文件是修改最多次数的；目录大小；带有文件数量和代码行数的Repository tree。StatSVN当前版本能够生成一组包括表格与图表的静态HTML文档。</p><h3 id="3-2-StatSVN下载"><a href="#3-2-StatSVN下载" class="headerlink" title="3.2. StatSVN下载"></a>3.2. StatSVN下载</h3><p>StartSVN官网地址为：<a href="http://www.statsvn.org/index.html">http://www.statsvn.org/index.html</a></p><p>StartSVN的下载页面为：<a href="http://www.statsvn.org/downloads.html">http://www.statsvn.org/downloads.html</a></p><p>实测时，官网上最新的版本为：statsvn-0.7.0</p><h3 id="3-3-StatSVN使用须知"><a href="#3-3-StatSVN使用须知" class="headerlink" title="3.3. StatSVN使用须知"></a>3.3. StatSVN使用须知</h3><p>StatSVN的运行需要Java的运行环境支持，所以大家需要安装Java的运行环境（Java Runtime Environment）。JRE可以从Sun的网站上下载。</p><p>Statsvn在使用中需要使用SVN的客户端，因此需要确保机器上可以访问到SVN的客户端命令</p><h3 id="3-4-Checkout工作拷贝"><a href="#3-4-Checkout工作拷贝" class="headerlink" title="3.4. Checkout工作拷贝"></a>3.4. Checkout工作拷贝</h3><p>首先从SVN仓库中checkout一个需要统计的路径（如果在工作目录下进行统计，首先请更新，保证工作区中的版本是最新的版本，确保统计结果的准确性），例如我把我的某个路径下的工程checkout在我的电脑上的D:\MyProjects路径下。</p><h3 id="3-5-生成svn-log文件"><a href="#3-5-生成svn-log文件" class="headerlink" title="3.5. 生成svn log文件"></a>3.5. 生成svn log文件</h3><p>首先通过命令行进入工作目录：D:\MyProjects ，再使用svn log -v –xml &gt; logfile.log的命令，其中logfile.log为log文件的名称，可以根据需要自行定义。这样就在工作拷贝的目录下生成一个名称为logfile.log的文件。</p><p>注：要在命令行中使用svn命令，在安装TortoiseSVN时必须选择安装commend组件，可以在cmd命令行里输入svn help测试一下该组件是否安装，如果未安装是无法使用svn log命令的。如果能够操作svn server的话也可以直接在服务器上生成svn log然后下载到本地来使用</p><h3 id="3-6-调用StatSVN进行统计"><a href="#3-6-调用StatSVN进行统计" class="headerlink" title="3.6. 调用StatSVN进行统计"></a>3.6. 调用StatSVN进行统计</h3><p>首先我们把从官网上下载的statsvn-0.7.0.zip包解压缩到D:\statsvn-0.7.0目录下</p><p>通过命令行进入D:\statsvn-0.7.0目录</p><p>调用命令：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">java -jar statsvn.jar</span><br></pre></td></tr></table></figure><p>D:\MyProjects\logfile.log D:\MyProjects，命令运行成功即完成了统计工作。</p><p>该命令的格式是:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">java -jar statsvn.jar [options] &lt;logfile&gt; &lt;checked-out-<span class="keyword">module</span>&gt;</span><br></pre></td></tr></table></figure><p>参数<logfile>为前一步中生成的svn log文件，<checked-out-module>为checkout工作拷贝目录，注意两个参数都要列出正确的全路径，否则会提示错误如logfile.log找不到等等</p><h3 id="3-7-基本操作："><a href="#3-7-基本操作：" class="headerlink" title="3.7. 基本操作："></a>3.7. 基本操作：</h3><ol><li><p>先导出svn log</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">svn log -v --xml -r Startrevision:Endrevision &gt; svn.log local_project</span><br></pre></td></tr></table></figure><p>其中Startrevision和Endrevision用来导出一个revision段的svn日志.local_project是svn上的project checkout到本地的结果.</p></li><li><p>通过statsvn工具做分析</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">java -jar statsvn.jar svn.log local_project</span><br></pre></td></tr></table></figure><p>运行完成后,就会在$PWD(unix下)或者%CD%(windows下)下生成对应的分析文件,在index.html文件中就有代码量统计。</p></li></ol><h3 id="3-8-统计输出格式："><a href="#3-8-统计输出格式：" class="headerlink" title="3.8. 统计输出格式："></a>3.8. 统计输出格式：</h3><p>输出以html的方式展示统计内容。（如下图）<br><img src="/../images/article/20160926164500420.png"> </p><h3 id="3-9-实测点评："><a href="#3-9-实测点评：" class="headerlink" title="3.9. 实测点评："></a>3.9. 实测点评：</h3><h4 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h4><ol><li>StatSVN会把当前SVN库的状态用图片和图表的方式展现出来，可以按不同分类分别展开，功能强大。</li></ol><h4 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h4><ol><li>StatSVN统计的是所有代码行，包括注释和空行，但一般度量要求是有效代码行，在分析时需要注意这一点。</li><li>StatSVN不考虑修改的代码行数，只考虑与上一版本相比新增(+)与删除(-)的代码行数。</li></ol><blockquote><p>点评：统计结果以图标的形式表现，功能比较强大，因为统计的内容比较多，个人感觉准确率一般。</p></blockquote><h2 id="4-Diffcount"><a href="#4-Diffcount" class="headerlink" title="4. Diffcount"></a>4. Diffcount</h2><h3 id="4-1-相关说明："><a href="#4-1-相关说明：" class="headerlink" title="4.1. 相关说明："></a>4.1. 相关说明：</h3><p><code>diffcount</code>代码行差异统计工具，用于比较两个代码包的新增，修改，删除的代码量.资源挺好的，统计出来的结果和我自己统计的有些差异。可以统计的文件类型有些少，而且偏后端语言。另外，在windows下使用的时候，直接敲命令行即可。</p><h3 id="4-2-主要功能："><a href="#4-2-主要功能：" class="headerlink" title="4.2. 主要功能："></a>4.2. 主要功能：</h3><ol><li>差异统计：统计某一个版本的代码包相对于一个原始的基线代码包，变动的代码量，以及变动的代码量中各语言非空非注释行(NBNC)的结果；</li><li>代码统计：如果需要，可以把diffcount当作普通的代码行统计工具，统计一个代码包；<br><code>diffcount</code>命令行方式的编译是直接通过Makefile进行的，目前提供Linux,Cygwin,Windows(MinGW)三种环境下的编译脚本，其他环境中，如果需要编译和使用，请通过修改Makefile文件进行。</li></ol><p><code>diffcount</code>的可执行程序名为 <code>diffcount.exe</code></p><p>想查询参数信息，请使用 <code>diffcount --help</code> 查询帮助<br> <br><code>diffcount --cn-help</code> 可以查询中文帮助， 也可以查看doc下的”命令行参数说明.txt”</p><h3 id="4-3-参数说明："><a href="#4-3-参数说明：" class="headerlink" title="4.3. 参数说明："></a>4.3. 参数说明：</h3><p><code>diffcount</code>的参数说明：</p><p>使用方法:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">diffcount [OPTION]... (Baseline) Target</span><br></pre></td></tr></table></figure><p>功能：对两个代码包进行差异统计、或者对一个代码包进行代码行统计packages 是差异统计的两个对象，也可以是仅作统计的一个对象</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">  -c --count-only  FILE/DIR</span><br></pre></td></tr></table></figure><p>仅仅对一个文件或者目录完成统计代码行的功能，没有比较对象，这样Packages参数的数量只能有一个（文件或目录）</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">   --ignore-<span class="keyword">case</span>  (DIFF USE ONLY)</span><br></pre></td></tr></table></figure><p>在比较的时候，忽略文件名的大小写差异(缺省情况会作为两个完全不同的文件）仅在“差异统计”时有效。</p><blockquote><p>Tips: 一些产品的代码，存在不同的版本的目录和文件的大小写不一样的情况可能是copy或者传送过程中造成的，对于这种情况，请使用该开关。</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">  --print-lines-info  (DEBUG USE OLY)</span><br></pre></td></tr></table></figure><p>输出每个文件差异比较后的差异结果和初步统计信息（逐行）,主要用于分析错误</p><blockquote><p>注意：不要针对大型代码包使用，否则逐行打印时间消耗惊人</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">  --print-files-info</span><br></pre></td></tr></table></figure><p>使用这个开关，当每个文件差异比较和统计以后，输出该文件差异统计的结果信息</p><p>缺省不打印每个文件的信息，只打印最后的结果</p><blockquote><p>Tips: 上边两个开关都需要打印控制台，如果文件较多的话，打印的时间会很长</p></blockquote><p>因此除非有具体分析需要，否则尽量不要打开</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">  --force-parse-all (DIFF USE ONLY)</span><br></pre></td></tr></table></figure><p>强制对所有文件进行分析处理（即使它们是完全相同的)，缺省对完全相同的文件略过</p><p>仅在“差异统计”时有效，代码行统计(count-only)时所有文件都要处理</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">  --<span class="keyword">for</span>-program-reading</span><br></pre></td></tr></table></figure><p>改变输出方式，以格式化文本形式输出，便于其他程序读取结果信息在由第三方程序调用diffcount，并需要读取统计结果的时候使用，该选项会屏蔽–print-lines-info选项</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">  -v  --version  </span><br></pre></td></tr></table></figure><p>输出当前的版本信息</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">  --help</span><br></pre></td></tr></table></figure><p>输出帮助信息</p><h3 id="4-4-使用方法："><a href="#4-4-使用方法：" class="headerlink" title="4.4. 使用方法："></a>4.4. 使用方法：</h3><h4 id="4-4-1-差异统计"><a href="#4-4-1-差异统计" class="headerlink" title="4.4.1. 差异统计"></a>4.4.1. 差异统计</h4><p>统计某一个版本的代码包相对于一个原始的基线代码包，变动的代码量以及变动的代码量中各语言非空非注释行(NBNC)的结果</p><p><code>diffcount</code> 缺省执行的就是差异统计，直接跟上两个代码包的目录即可</p><p>在<code>diffcount</code>目录下执行：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">diffcount test\sp1 test\sp2</span><br></pre></td></tr></table></figure><p>实际使用中，可能会有文件名和目录名大小写不一致的情况，如果希望忽略文件名大小写的差异，需要使用 –ignore-case参数，否则两个一样的文件，一个会算作删除，一个会算作新增<br><img src="/../images/article/20160927141326402.png"></p><p><code>ADD MOD DEL A&amp;M BLK CMT NBNC RATE</code> 的 含义分别为：<code>新增、修改、删除、新增+修改、空行、注释、非空非注释行、标准C折算率</code></p><h4 id="4-4-2-代码统计："><a href="#4-4-2-代码统计：" class="headerlink" title="4.4.2. 代码统计："></a>4.4.2. 代码统计：</h4><p>如果需要，可以把<code>diffcount</code>当作普通的代码行统计工具，统计一个代码包</p><p>代码统计使用 -c (或者–count-only)参数,在diffcount目录下执行</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">diffcount -c  test\count</span><br></pre></td></tr></table></figure><p>执行结果如下：<br><img src="/../images/article/20160927141341752.png"> </p><h3 id="4-5-实测点评："><a href="#4-5-实测点评：" class="headerlink" title="4.5. 实测点评："></a>4.5. 实测点评：</h3><p><code>Diffcount</code> 主要功能包括代码统计和差异统计，代码统计操作通过命令式方式操作，总体操作还算简单，适合开发者操作，代码统计相对于上面其他三个没特别优势，如果是想用差异统计推荐使用<code>Diffcount</code>。</p>]]></content>
      
      
      <categories>
          
          <category> 实用工具 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 实用工具 </tag>
            
            <tag> 代码统计 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>跨平台之AppCan与DeviceOne对比点评记录</title>
      <link href="/posts/2972603156.html"/>
      <url>/posts/2972603156.html</url>
      
        <content type="html"><![CDATA[<p>目前已有的移动中间件开发技术主要包括：<code>IOS</code>、<code>Android</code>或<code>WindowsPhone</code>的纯原生开发；以<code>Html5</code>技术为核心的中间件开发（例如：<code>PhoneGap</code>, <code>HBuilder</code>, <code>AppCan</code>, <code>ApiCloud</code>）；以<code>OpenGL</code>技术为核心的中间件开发(例如：<code>CrossApp</code>)；以代码转换和原生反射技术为核心的中间件开发(例如：<code>Titanium</code>，<code>Xamarin</code>，<code>ReactNative</code>)；以及以虚拟UI、抽象SDK、动态组件为核心的中间件开发（例如：<code>DeviceOne</code>）。</p><p>本次主要拿 <code>AppCan</code> 与 <code>DeviceOne</code> 做对比，说下它们的共同点、不同点和各自的特性</p><h3 id="AppCan-与-DeviceOne共同点和不同点："><a href="#AppCan-与-DeviceOne共同点和不同点：" class="headerlink" title="AppCan 与 DeviceOne共同点和不同点："></a><code>AppCan</code> 与 <code>DeviceOne</code>共同点和不同点：</h3><h4 id="共同点："><a href="#共同点：" class="headerlink" title="共同点："></a>共同点：</h4><ol><li>跨平台，都支持目前的三大主流系统：Android,iOS,WindowsPhone</li><li>都是以提取Eclipse开发工具的基本功能并稍作修改后，集成自己的IDE来给开发者一个独立的开发工具。</li></ol><h4 id="不同点："><a href="#不同点：" class="headerlink" title="不同点："></a>不同点：</h4><ol><li><code>AppCan</code>主要采用<code>HTML5</code>+<code>CSS3</code>+<code>JS</code>来开发</li><li><code>DeviceOne</code>主要采用<code>JS</code>或<code>Lua</code>来开发</li></ol><h3 id="AppCan-与-DeviceOne各自特性："><a href="#AppCan-与-DeviceOne各自特性：" class="headerlink" title="AppCan 与 DeviceOne各自特性："></a><code>AppCan</code> 与 <code>DeviceOne</code>各自特性：</h3><h3 id="AppCan"><a href="#AppCan" class="headerlink" title="AppCan:"></a>AppCan:</h3><h4 id="核心："><a href="#核心：" class="headerlink" title="核心："></a>核心：</h4><pre><code>以`html5技术`为核心的中间件开发。（主推`Hybrid`模式）</code></pre><h4 id="优点："><a href="#优点：" class="headerlink" title="优点："></a>优点：</h4><ol><li>支持四大主流系统：<code>Android</code>,<code>iOS</code>,<code>Symbian</code>,<code>WindowsPhone</code></li><li>提供一体化解决方案，方便环境搭建、开发、调试、发布</li><li>框架自带UI包，包含常用控件样式</li><li>框架API丰富</li><li>支持本地打包、云端打包</li><li>基于密钥的代码加密</li><li>框架对UI、动画渲染进行过优化，反应速度比纯html5快</li></ol><h4 id="缺点："><a href="#缺点：" class="headerlink" title="缺点："></a>缺点：</h4><ol><li>不开源，无法修改、优化底层代码</li><li>暂不支持自行开发控件，无法调取android原生功能</li><li>框架自带功能过多，导致应用安装包偏大。</li><li>部分系统无法使用IDE进行调试</li><li>只能在服务器端发布，无法在本地发布（即代码需上传至服务器才能发布）</li><li>IOS发布，需要将证书上传至服务器</li></ol><h3 id="DeviceOne"><a href="#DeviceOne" class="headerlink" title="DeviceOne:"></a>DeviceOne:</h3><h4 id="核心：-1"><a href="#核心：-1" class="headerlink" title="核心："></a>核心：</h4><pre><code>以`虚拟UI`、`抽象SDK`、`动态组件`为核心的中间件开发。</code></pre><h4 id="优点：-1"><a href="#优点：-1" class="headerlink" title="优点："></a>优点：</h4><ol><li>支持三大主流系统：<code>Android</code>,<code>iOS</code>,<code>WindowsPhone</code></li><li>UI布局可拖拽</li><li>屏幕自动适配</li><li>UI是原生的</li><li>开放的组件商店，可自定义组件</li></ol><h4 id="缺点：-1"><a href="#缺点：-1" class="headerlink" title="缺点："></a>缺点：</h4><ol><li>不支持本地打包，需要远程（服务器）打包</li><li>组件商店的公共组件太少</li><li>推出时间太短，市场检验的时间还够</li><li>相关的文档资料太少</li></ol><p>本次的<code>AppCan</code>与<code>DeviceOne</code>对比点评就到这里~</p>]]></content>
      
      
      <categories>
          
          <category> 跨平台 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 跨平台 </tag>
            
            <tag> AppCan </tag>
            
            <tag> DeviceOne </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
